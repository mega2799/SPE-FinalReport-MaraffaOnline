<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>main</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="latex2html.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#list-of-abbreviations" id="toc-list-of-abbreviations">List
of Abbreviations</a></li>
<li><a href="#ch:into" id="toc-ch:into">Introduction</a></li>
<li><a href="#ch:ddd" id="toc-ch:ddd">Domain Driven Design</a>
<ul>
<li><a
href="#knowledge-crunching-session-for-the-exploration-of-the-problem-space"
id="toc-knowledge-crunching-session-for-the-exploration-of-the-problem-space">Knowledge
crunching session for the exploration of the problem space</a></li>
<li><a href="#ubiquitos-language" id="toc-ubiquitos-language">Ubiquitos
Language</a></li>
<li><a href="#bounded-context" id="toc-bounded-context">Bounded
Context</a></li>
<li><a href="#requisiti-e-casi-duso"
id="toc-requisiti-e-casi-duso">Requisiti e casi d’uso</a>
<ul>
<li><a href="#requisiti" id="toc-requisiti">Requisiti</a></li>
<li><a href="#casi-duso" id="toc-casi-duso">Casi d’uso</a></li>
</ul></li>
<li><a href="#riflessioni" id="toc-riflessioni">Riflessioni</a></li>
</ul></li>
<li><a href="#ch:implementation"
id="toc-ch:implementation">Implementation</a>
<ul>
<li><a href="#implementation"
id="toc-implementation">Implementation</a></li>
<li><a href="#task.registry"
id="toc-task.registry">TASK.REGISTRY?????</a></li>
</ul></li>
<li><a href="#ch:DevOps" id="toc-ch:DevOps">DevOps</a>
<ul>
<li><a href="#semantic-versioning-e-changelog-e-secrets"
id="toc-semantic-versioning-e-changelog-e-secrets">Semantic Versioning e
Changelog e secrets</a>
<ul>
<li><a href="#semantic-versioning" id="toc-semantic-versioning">Semantic
Versioning</a></li>
<li><a href="#changelog-e-secrets"
id="toc-changelog-e-secrets">Changelog e secrets</a></li>
</ul></li>
<li><a href="#licensing-e-issue-template"
id="toc-licensing-e-issue-template">Licensing e issue template</a></li>
<li><a href="#git-section-non-so-come-chiamarla"
id="toc-git-section-non-so-come-chiamarla">Git section; non so come
chiamarla</a>
<ul>
<li><a href="#strategy-for-version-control"
id="toc-strategy-for-version-control">Strategy for version
control</a></li>
<li><a href="#git-workflow" id="toc-git-workflow">Git workflow</a></li>
<li><a href="#commit-verification" id="toc-commit-verification">Commit
verification</a></li>
<li><a href="#conventional-commits"
id="toc-conventional-commits">Conventional commits</a></li>
</ul></li>
<li><a href="#build-automation" id="toc-build-automation">Build
automation</a></li>
<li><a href="#continuous-integration"
id="toc-continuous-integration">Continuous Integration</a></li>
<li><a href="#automated-quality-assurance"
id="toc-automated-quality-assurance">Automated quality
assurance</a></li>
<li><a href="#automated-delivery" id="toc-automated-delivery">Automated
delivery</a></li>
<li><a href="#deployment" id="toc-deployment">Deployment</a></li>
<li><a href="#containerization"
id="toc-containerization">Containerization</a></li>
</ul></li>
<li><a href="#ch:con" id="toc-ch:con">Conclusions and Future Work</a>
<ul>
<li><a href="#conclusions" id="toc-conclusions">Conclusions</a></li>
<li><a href="#future-work" id="toc-future-work">Future work</a></li>
</ul></li>
</ul>
</nav>
<div class="titlepage">
<div class="center">
<p><span>Software Process Engineering</span><br />
</p>
<p>Maraffa Online</p>
<p> <br />
<span> Sofia Tosi, Matteo Santoro </span><br />
</p>
<p>2024-06-03</p>
</div>
</div>
<h2 id="list-of-abbreviations">List of Abbreviations</h2>
<div class="abbrv">
<p>School of Mathematical, Physical and Computational Sciences</p>
</div>
<h1 id="ch:into">Introduction</h1>
<p>MaraffaOnline è un’applicazione che permette alle persone di giocare
al gioco di carte <a
href="https://it.wikipedia.org/wiki/Marafone_Beccacino">Maraffa/Beccacino</a>.
Il progetto consiste nell’eseguire una manutenzione evolutiva del gioco
di carte reperibile su MaraffaOnline, attualmente sviluppato dalla
prof.ssa Lumini. In particolare la nuova versione avrà un’architettura a
microservizi e introdurrà anche nuove funzionalità come formazione
personalizzata delle squadre, una nuova modalità di gioco (vittoria 11 a
0 in caso di violazione delle regole da parte di una squadra),
salvataggio delle statistiche delle partite e degli utenti, ...<br />
Per lo sviluppo è stato seguito un approccio Domain Driven Design, per
il quale si è approfondito il dominio del gioco.<br />
È stata posta particolare attenzione alle tecniche di continuos
integration, alle quali è stato dedicato uno dei capitoli di questo
report.</p>
<h1 id="ch:ddd">Domain Driven Design</h1>
<h2
id="knowledge-crunching-session-for-the-exploration-of-the-problem-space">Knowledge
crunching session for the exploration of the problem space</h2>
<p>Per ottenere maggior chiarezza sul dominio è stato utilizzato il
metodo Even Storming. La tecnica consiste nell’individuare degli eventi
di dominio e riportarli al passato su un post-it arancione. Una volta
individuati gli eventi, sono stati scritti su post-it blu i comandi che
l’utente svolge per creare l’evento. In giallo è stato specificato
l’attore, la persona che esegue il comando, mentre in verde la view,
l’interfaccia software con la quale l’utente interagisce. Infine, con
delle label si sono aggregati i post-it in unità di dominio. Si riporta
di seguito lo screen della lavagna con i post-it e la relativa
legenda.</p>
<figure id="event_storming">
<img src="report/img/EventStorming.png" />
<figcaption>Event Storming</figcaption>
</figure>
<figure id="legend">
<img src="report/img/Event_storming_legend.png" />
<figcaption>Event Storming Legend</figcaption>
</figure>
<h2 id="ubiquitos-language">Ubiquitos Language</h2>
<div class="adjustbox">
<p><span>max width=1.1,center</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Nome</th>
<th style="text-align: left;">Descrizione</th>
<th style="text-align: left;">Sinonimi</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Mano</td>
<td style="text-align: left;">Distribuzione delle 40 carte ai 4
giocatori e la seguente serie di 10 prese</td>
<td style="text-align: left;">Round</td>
</tr>
<tr class="even">
<td style="text-align: left;">Mano</td>
<td style="text-align: left;">Carte dei giocatori non ancora
giocate</td>
<td style="text-align: left;">Hand</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Presa</td>
<td style="text-align: left;">Quando ogni giocatore, a turno, gioca sul
tavolo una carta. L’ultima presa della mano vale 1 punto.</td>
<td style="text-align: left;">Trick</td>
</tr>
<tr class="even">
<td style="text-align: left;">Partita</td>
<td style="text-align: left;">Insieme di più mani fino al raggiungimento
del punteggio di 41 punti.</td>
<td style="text-align: left;">Game</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Partita corta</td>
<td style="text-align: left;">Insieme di più mani fino al raggiungimento
del punteggio di 31 punti.</td>
<td style="text-align: left;">Short Game</td>
</tr>
<tr class="even">
<td style="text-align: left;">Tavolo</td>
<td style="text-align: left;">Raggruppamento di 4 giocatori, suddivisi
in 2 coppie, i giocatori delle stessa squadra “siedono” in direzione
opposta</td>
<td style="text-align: left;">Table</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Seme</td>
<td style="text-align: left;">Tipologia distintiva di carta, ne esistono
4: Denari, Coppe, Spade, Bastoni</td>
<td style="text-align: left;">Suit: Coins, Cups, Swords, Clubs </td>
</tr>
<tr class="even">
<td style="text-align: left;">Briscola</td>
<td style="text-align: left;">Seme con priorita’ piu’ alta.</td>
<td style="text-align: left;">Trump</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Maraffa</td>
<td style="text-align: left;">Se un giocatore possiede le tre carte di
valore maggiore (asso, due e tre, dette assieme "Maraffa" o "Cricca")
del seme di briscola, vince tre punti addizionali. In questo caso deve
scendere con l’asso di quel seme.</td>
<td style="text-align: left;">Cricca, Marafon, Tresette con la
Briscola</td>
</tr>
<tr class="even">
<td style="text-align: left;">Mazzo</td>
<td style="text-align: left;">40 carte, di 4 semi diversi,
1,2,3,4,5,6,7, fante, cavallo e re.</td>
<td style="text-align: left;">Deck</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Taglio</td>
<td style="text-align: left;">Durante una mano in un seme viene giocato
il seme di briscola, che avendo priorita’ maggiore permette di prendere
nonostante il seme di gioco</td>
<td style="text-align: left;">Cut</td>
</tr>
<tr class="even">
<td style="text-align: left;">Busso</td>
<td style="text-align: left;">Invita il compagno, se possibile, a
conquistare la presa e ad aprire il turno successivo con lo stesso
seme</td>
<td style="text-align: left;">Knock</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Striscio corto</td>
<td style="text-align: left;">Quando si ha ancora in mano un basso
numero di carte dello stesso seme con cui si è aperto il turno.</td>
<td style="text-align: left;">Short strip</td>
</tr>
<tr class="even">
<td style="text-align: left;">Striscio lungo</td>
<td style="text-align: left;">Quando si ha ancora in mano molte carte
dello stesso seme con cui si è aperto il turno.</td>
<td style="text-align: left;">Long strip</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Volo</td>
<td style="text-align: left;">Quando non si hanno più carte del seme con
cui si è aperto il turno.</td>
<td style="text-align: left;">Fly</td>
</tr>
<tr class="even">
<td style="text-align: left;">Figura</td>
<td style="text-align: left;">Fante, Cavallo, Re, con punteggio di 1/3
di punto.</td>
<td style="text-align: left;">Figure</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Asso</td>
<td style="text-align: left;">Carta con valore di 1 punto.</td>
<td style="text-align: left;">Ace</td>
</tr>
<tr class="even">
<td style="text-align: left;">Due e Tre</td>
<td style="text-align: left;">Carte con valore 1/3 di punto.</td>
<td style="text-align: left;">Two and Three</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Carta Liscia</td>
<td style="text-align: left;">Carte con numeri 4, 5, 6, 7. Sono prive di
valore</td>
<td style="text-align: left;">Smooth paper</td>
</tr>
<tr class="even">
<td style="text-align: left;">Squadra</td>
<td style="text-align: left;">Coppie di giocatori seduti opposti</td>
<td style="text-align: left;">Team</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Giocatore</td>
<td style="text-align: left;">Persona che interagisce con
l’applicativo</td>
<td style="text-align: left;">Player, User</td>
</tr>
<tr class="even">
<td style="text-align: left;">Chiamata fuori</td>
<td style="text-align: left;">Se un giocatore pensa che la sua squadra
abbia raggiunto i 41 punti (o 31 punti nella variante "corta" della
partita), la squadra può dichiarare di avere già nel mazzo delle prese i
punti per vincere e chiudere in anticipo l’ultima partita. In questo
modo la mano termina immediatamente, senza che vengano giocate le
restanti prese e la squadra che si è "chiamata fuori" impedisce
all’altra squadra di conquistare ulteriori prese. Se una squadra si
chiama fuori e, dopo aver contato i punti delle prese effettuate ed
averli sommati ai punti ottenuti nelle mani già giocate, non raggiunge i
punti per la vittoria (in gergo "sbaglia la chiamata") scatta automatico
l’11 a 0 per la squadra avversaria</td>
<td style="text-align: left;">Call out</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Modalità di gioco</td>
<td style="text-align: left;">regole di gioco classiche o varianti che
influenzano aspetti come il punteggio, condizioni di vittoria/perdita,
... Ne sono state implementate due: classica, 11 a 0.</td>
<td style="text-align: left;">Game mode</td>
</tr>
</tbody>
</table>
</div>
<h2 id="bounded-context">Bounded Context</h2>
<p>Analizzando il dominio di MaraffaOnline, sono stati identificati tre
bounded context. Nella figura si può osservare un primo bounded context,
colorato di azzurro, che modella l’autenticazione dell’utente:</p>
<ul>
<li><p><strong>User:</strong> persona che possiede l’account</p></li>
<li><p><strong>Statistic:</strong> dati dell’utente relativi al gioco
come numero di vittorie, sconfitte, partite giocate e maraffe</p></li>
<li><p><strong>Authentication:</strong> accesso all’applicativo
MaraffaOnline da parte dell’utente</p></li>
</ul>
<p>Il secondo bounded context, colorato di verde, modella la
partita:</p>
<ul>
<li><p><strong>Game:</strong> partita</p></li>
<li><p><strong>Team:</strong> squadra composta da numero di giocatori /
2</p></li>
<li><p><strong>Score:</strong> punteggio delle due squadre</p></li>
<li><p><strong>Statistic:</strong> dati relativi ai game
giocati</p></li>
<li><p><strong>Trick:</strong> presa di quattro carte da parte di un
giocatore</p></li>
<li><p><strong>Round:</strong> 10 prese</p></li>
<li><p><strong>Card:</strong> carta</p></li>
<li><p><strong>Player:</strong> giocatore</p></li>
<li><p><strong>Deck:</strong> mazzo</p></li>
<li><p><strong>Hand:</strong> carte che ha in mano un giocatore</p></li>
</ul>
<p>Infine l’ultimo, di colore arancione, modella la chat:</p>
<ul>
<li><p><strong>Chat:</strong> chat di gioco</p></li>
<li><p><strong>Message:</strong> messaggio inviato nella chat</p></li>
<li><p><strong>User:</strong> persona che invia il messaggio</p></li>
</ul>
<p>È importante notare che il concetto di user/player è polisemico: vi
sono tre rappresentazioni diverse per afferire allo stesso concetto.</p>
<figure id="bounded_context">
<img src="report/img/BoundedCTX.png" />
<figcaption>Context Map</figcaption>
</figure>
<h2 id="requisiti-e-casi-duso">Requisiti e casi d’uso</h2>
<h3 id="requisiti">Requisiti</h3>
<ol>
<li><p>Account</p>
<ol>
<li><p>Login</p></li>
<li><p>Registrazione</p></li>
<li><p>Recupero password</p></li>
<li><p>Visualizzazione profilo</p></li>
<li><p>Modifica password</p></li>
<li><p>Possibilità di scegliere se giocare come ospite o effettuare il
login</p></li>
</ol></li>
<li><p>Realizzazione partita</p>
<ol>
<li><p>Creazione partita</p></li>
<li><p>Partecipazione partita</p></li>
<li><p>gioca carta</p></li>
<li><p>Inizio partita</p></li>
<li><p>Fine mano</p></li>
<li><p>Fine partita</p></li>
</ol></li>
<li><p>Chat di gioco</p>
<ol>
<li><p>chat globale</p></li>
<li><p>chat partita</p></li>
</ol></li>
<li><p>Possibilità di scegliere un compagno di squadra</p></li>
<li><p>Scelta del seme, parole consentite</p></li>
<li><p>Modalità di gioco 11 a 0</p></li>
<li><p>Gestione punteggio</p>
<ol>
<li><p>Calcolo totale e parziale (Gestione per ogni mano) del
punteggio</p></li>
<li><p>Maraffa/Cricca (+3 punti)</p></li>
</ol></li>
<li><p>Servizio gestione utenti</p></li>
<li><p>Salvataggio statistiche</p></li>
<li><p>Realizzazione GUI</p>
<ol>
<li><p>Refactor della GUI esistente</p></li>
<li><p>Rinnovamento GUI</p></li>
</ol></li>
</ol>
<h3 id="casi-duso">Casi d’uso</h3>
<p>Si riporta di seguito lo schema dei casi d’uso che modella
l’interazione dell’utente con l’applicazione.</p>
<figure id="use_case">
<img src="report/img/Casi_duso.png" />
<figcaption>Schema dei casi d’uso</figcaption>
</figure>
<h2 id="riflessioni">Riflessioni</h2>
<p>**Spiegare per quale motivo i pattern del DDD non sono stati
applicati** (shared kernel, publish consumer, ...)</p>
<h1 id="ch:implementation">Implementation</h1>
<h2 id="implementation">Implementation</h2>
<h2 id="task.registry">TASK.REGISTRY?????</h2>
<h1 id="ch:DevOps">DevOps</h1>
<h2 id="semantic-versioning-e-changelog-e-secrets">Semantic Versioning e
Changelog e secrets</h2>
<h3 id="semantic-versioning">Semantic Versioning</h3>
<p>Per ogni release è stato adottato il semanting Versioning. È stato
utilizzato il formato X.Y.Z, partendo da 1.0.0, ogni release incrementa
il numero di versione in base a:</p>
<ul>
<li><p><strong>Major (X):</strong> per cambiamenti incompatibili con le
versioni precedenti</p></li>
<li><p><strong>Minor (Y):</strong> per aggiunta di nuove funzionalità
compatibili con le versioni precedenti</p></li>
<li><p><strong>Patch (Z):</strong> per correzione di bug compatibili con
le versioni precedenti</p></li>
</ul>
<p>Per ogni release viene creato anche un tag con la corrispondente
versione.</p>
<h3 id="changelog-e-secrets">Changelog e secrets</h3>
<p>Ogni volta che is effettua una push sul main, viene generato un
changelog. Il changelog è un file che contiene tutte le modifiche
effettuate. Nel changelog vengono riportati ogni commit che indicano le
modifiche apportate, i contributori e il codice sorgente. Se presenti,
vengono inoltre riportate le sezioni:</p>
<ul>
<li><p><strong>feat: Feature</strong> per le nuove funzionalità</p></li>
<li><p><strong>fix: Bug Fixes</strong> per le correzioni di bug</p></li>
<li><p><strong>docs: Documentation</strong> per le modifiche alla
documentazione</p></li>
<li><p><strong>refactor: Refactor</strong> per le modifiche al codice
che non aggiungono nuove funzionalità</p></li>
<li><p><strong>perf: Performance Improvements</strong> per le modifiche
che migliorano le prestazioni</p></li>
<li><p><strong>CI: Continuos Integration</strong> per le modifiche alla
CI</p></li>
</ul>
<p>Il changelog viene autogenerato tramite l’action
’BobAnkh/auto-generate-changelog@v1.2.5’. Inoltre per evitare un accesso
non autorizzato a dati sensibili, come l’access token del changelog,
sono stati inseriti in secrets, variabili d’ambiente di Github.</p>
<h2 id="licensing-e-issue-template">Licensing e issue template</h2>
<p>In ogni nostra repo è presente una licenza MIT. È stata scelta questa
licenza perché è estremamente permissiva: il codice sorgente di Maraffa
Online è open source e pertanto gli utenti possono utilizzarlo,
modificarlo e distribuirlo. Inoltre la licenza MIT è compatibile anche
con altre licenze, anche con quelle restrittive come GPL. È incoraggiata
la collaborazione anche grazie alla presenza di un template con il quale
un utente può consigliare nuove feature, segnalare un bug o suggerire
un’implementazione alternativa.</p>
<h2 id="git-section-non-so-come-chiamarla">Git section; non so come
chiamarla</h2>
<h3 id="strategy-for-version-control">Strategy for version control</h3>
<p>**parla della git policy**</p>
<h3 id="git-workflow">Git workflow</h3>
<p>**main, develop, feature branch...***</p>
<h3 id="commit-verification">Commit verification</h3>
<p>È stato utilizzato il meccanismo di commit verification per
assicurare:</p>
<ul>
<li><p><strong>Integrità:</strong> controllo sull’alterazione dei file
presenti all’interno del commit. Utilizzando una funzione hash, ci si
assicura che non siano stati alterati in non modo autorizzato.</p></li>
<li><p><strong>Autenticità:</strong> controllo sull’autore del commit.
Utilizzando una firma digitale, ci si assicura che il commit sia stato
effettuato dall’autore autorizzato.</p></li>
</ul>
<p>I controlli vengono effettuati in seguito a un merge.<br />
Quando un commit è verificato viene prodotto un tag verde con la scritta
"verified" e un tag rosso con la scritta "unverified" in caso
contrario:</p>
<figure id="verified_commit">
<img src="report/img/verified_commit.png" />
<figcaption>Verified commit</figcaption>
</figure>
<h3 id="conventional-commits">Conventional commits</h3>
<p>In ogni repo è stato adottato un sistema standard per scrivere i
commit: i conventional commit. In questo modo i commit risultano più
chiari e facilmente leggibili. Riportiamo di seguito la nomenclatura
usata:</p>
<ul>
<li><p><strong>fix:</strong> per i commit che risolvono un bug</p></li>
<li><p><strong>feat:</strong> per i commit che aggiungono una nuova
feature</p></li>
<li><p><strong>refactor:</strong> per i commit che migliorano il codice
senza aggiungere nuove funzionalità</p></li>
<li><p><strong>docs:</strong> per i commit che riguardano la
documentazione</p></li>
<li><p><strong>style:</strong> per i commit che riguardano la
formattazione del codice</p></li>
<li><p><strong>test:</strong> per i commit che riguardano i
test</p></li>
<li><p><strong>ci:</strong> per i commit che riguardano la Continuous
Integration</p></li>
</ul>
<p>Inoltre sono evidenziati i breaking changes per le modifiche non più
compatibili con le versioni precedenti. La stessa nomenclatura viene
utilizzata anche nel changelog.</p>
<h2 id="build-automation">Build automation</h2>
<h2 id="continuous-integration">Continuous Integration</h2>
<p>Abbiamo deciso di implementare ogni servizio in una repository
diversa. La repository fornita è un contenitore di tutte le singole
repository dei servizi. Per ogni repository è stata implementata una CI
specifica.<br />
<strong>UserManagementMaraffa e BusinessLogic:</strong> Essendo le due
repository estremamente simili e avendo entrambe un ambiente in node.js,
è stato implementato un workflow pressochè analogo. Questo workflow
reagisce all’evento push sul main branch, e pull request sui branch main
e develop e sono stati implementati 3 job: build, test e deploy. Dopo
una checkout iniziale (fetch-depth è 0 in quanto il changelog necessita
di tutta la history dei commit), viene creata una cache per permettere
ai job di comunicare tra loro. Successivamente alla build il sistema
viene testato (in entrambi i casi viene usata l’action di yarn) e infine
viene effettuato il deploy del servizio containerizzato se l’evento è
una pull request con la quale viene svolto il merge e quando l’action è
closed (non sta progredendo e quindi l’esecuzione non è in corso). Nel
deploy viene effettuato il chekout, si configura il nome del progetto,
si configura la versione della build. Se il commit viene effettuato sul
main si configura il nome del tag e la versione a "LATEST", nel caso non
fosse nel main viene configurata la versione a "develop". Infine si
effettua il login al Github container registry, la build e la push
dell’immagine sul registro. L’immagine viene configurata in modo
parametrico con delle variabili d’ambiente e il nome viene trasformato
in minuscolo.</p>
<p><strong>MiddlewareMaraffa:</strong> //TODO push su main, pull request
su main e develop build e test se pullrequest.merge = true</p>
<p>Parte finale <strong>ChatServer:</strong> Il servizio è sviluppato in
un ambiente Java, pertanto dopo aver effettuato il checkout nel job
build and test, si effettua il set-up di Java (distribuzione: temurin,
versione 20). Viene svolto il set-up di Gradle, in cui viene usata
un’action per la build e creata una cache. Inoltre viene aggiunto un
commento con un riassunto dei risultati dei job alla pull request, il
cui valore è impostato a "on-failure". Si noti che il suo valore di
default è "never"; se fosse "always", si potrebbero verificare scenari
indesiderati. Il riassunto dei risultati dei job risulta particolarmente
utile: un utente che vuole esaminare la pull request riesce a
comprendere lo stato dei job (se sono stati eseguiti correttamente
oppure no) in modo leggibile e intuitivo. Successivamente si effettua il
deploy del container di rabbitMQ se l’evento è una pull request oppure
se è una push sul master o se la stringa con il riferimento a github
contiene "tags/v". Infine se tutti il job da cui dipende
(build-and-test) non è fallito e non è stato interrotto. Con
l’istruzione run si verifica che non ci siano stati dei fallimenti nel
job deploy and test.</p>
<p><strong>FrontendMaraffa:</strong> //TODO Sarebbe figo spiegare come i
nostri workflow hanno ridotto i conflitti di integrazione, il
rilevamento precoce di bug e i problemi di compatibilità.</p>
<h2 id="automated-quality-assurance">Automated quality assurance</h2>
<p>**code quality, testing, reporting**</p>
<h2 id="automated-delivery">Automated delivery</h2>
<p>**automatizzare l’esecuzione iniziale del sistema con build.gradle
che specifica come il file deve compilare, gestire dip e configurare
altri apetti del build process**</p>
<h2 id="deployment">Deployment</h2>
<p>è opzionale</p>
<h2 id="containerization">Containerization</h2>
<p>** docker image for each microservice, docker file docker compose
grouping containers and defining dependencies**</p>
<h1 id="ch:con">Conclusions and Future Work</h1>
<h2 id="conclusions">Conclusions</h2>
<p>**spiega che verrà messo online nel sitoweb **</p>
<p>**Replace with a description of the conclusions**</p>
<p>Typically a conclusions chapter first summarizes the investigated
problem and its aims and objectives. It summaries the
critical/significant/major findings/results about the aims and
objectives that have been obtained by applying the key
methods/implementations/experiment set-ups. A conclusions chapter draws
a picture/outline of your project’s central and the most signification
contributions and achievements.</p>
<p>A good conclusions summary could be approximately 300–500 words long,
but this is just a recommendation.</p>
<p>A conclusions chapter followed by an abstract is the last things you
write in your project report.</p>
<h2 id="future-work">Future work</h2>
<p>This section should refer to Chapter <a href="#ch:results"
data-reference-type="ref" data-reference="ch:results">[ch:results]</a>
where the author has reflected their criticality about their own
solution. The future work is then sensibly proposed in this section.</p>
<p><strong>Guidance on writing future work:</strong> While working on a
project, you gain experience and learn the potential of your project and
its future works. Discuss the future work of the project in technical
terms. This has to be based on what has not been yet achieved in
comparison to what you had initially planned and what you have learned
from the project. Describe to a reader what future work(s) can be
started from the things you have completed. This includes identifying
what has not been achieved and what could be achieved.</p>
<p>A good future work summary could be approximately 300–500 words long,
but this is just a recommendation.</p>
</body>
</html>
